import { gql } from 'apollo-server-express';
import { Context } from 'context';
import { neo4jgraphql } from 'neo4j-graphql-js';
import { returnRecipeIfUserHasAccess } from 'cypherFragments';

export const typeDefs = gql`
  enum RecipeDisplayType {
    LINK
    FULL
  }

  type Recipe {
    id: ID!
    title: String!
    description: String
    attribution: String
    sourceUrl: String
    published: Boolean!
    displayType: RecipeDisplayType

    servings: Int!
    # all times in minutes
    cookTime: Int
    prepTime: Int
    unattendedTime: Int

    createdAt: String!
    updatedAt: String!
    viewedAt: String!
    views: Int!

    locked: Boolean!
    private: Boolean!

    containedInViewerCollections(first: Int = 10, offset: Int = 0): [RecipeCollection!]! @authenticated
      @cypher(statement: """
      MATCH (this)-[:COLLECTED_IN]->(collection:RecipeCollection)<-[:HAS_COLLECTION]-(:Group)<-[:MEMBER_OF]-(:User{id:$cypherParams.userId})
      RETURN collection
      """
      )
  }

  enum RecipeLinkProblem {
    FailedIngredients
    IncompleteIngredients
    FailedImage
  }

  type RecipeLinkResult {
    recipe: Recipe!
    problems: [RecipeLinkProblem!]!
  }

  input RecipeCreateInput {
    title: String!
    description: String
    servings: Int
    cookTime: Int
    prepTime: Int
    unattendedTime: Int
    private: Boolean
  }

  input RecipeLinkInput {
    url: String!
  }

  input RecipeCollectInput {
    recipeId: ID!
    collectionId: ID!
  }

  input RecipeUpdateInput {
    title: String
    description: String
    servings: Int
    cookTime: Int
    prepTime: Int
    unattendedTime: Int
    private: Boolean
  }

  # normally this would be generated by neo4j-graphql-js, but we're not
  # using schema augmentation yet...
  enum _RecipeOrdering {
    title_asc
    title_desc
    views_asc
    views_desc
  }

  extend type Query {
    recipe(id: ID!): Recipe
      # here we're preventing users from seeing drafts by other users
      @cypher(
        statement: """
        MATCH (recipe:Recipe {id:$id})
        ${returnRecipeIfUserHasAccess()}
        """
      )

    recipes(
      orderBy: _RecipeOrdering
      first: Int = 10
      offset: Int = 0
    ): [Recipe!]!
      @cypher(
        statement: """
        MATCH (recipe:Recipe)
        ${returnRecipeIfUserHasAccess()}
        """
      )
  }

  extend type Mutation {
    createRecipe(input: RecipeCreateInput!): Recipe!
      @authenticated
      @generateId(fromArg: "input.title")
      @cypher(
        statement: """
        MATCH (user:User{id:$cypherParams.userId})
        CREATE (recipe:Recipe {id: $id})<-[:AUTHOR_OF]-(user)
        SET recipe += $input
        SET recipe.displayType = 'FULL'
        SET recipe.published = false
        RETURN recipe
        """
      )

    linkRecipe(input: RecipeLinkInput!): RecipeLinkResult! @authenticated

    updateRecipe(id: ID!, input: RecipeUpdateInput!): Recipe
      @authenticated
      @cypher(
        statement: """
        MATCH (:User{id:$cypherParams.userId})-[:AUTHOR_OF]->(recipe:Recipe{id:$id})
        SET recipe += $input
        RETURN recipe
        """
      )

    publishRecipe(id: ID!): Recipe
      @authenticated
      @cypher(
        statement: """
        MATCH (:User{id:$cypherParams.userId})-[:AUTHOR_OF]->(recipe:Recipe{id:$id})
        SET recipe.published = true
        RETURN recipe
        """
      )
    recordRecipeView(id: ID!): Recipe

    collectRecipe(input: RecipeCollectInput!): Recipe!
      @authenticated
      @cypher(
        statement: """
        MATCH (recipe:Recipe{id:$input.recipeId}),
          (user:User{id:$cypherParams.userId})-[:MEMBER_OF]->(group:Group)-[:HAS_COLLECTION]->(collection:RecipeCollection{id:$input.collectionId})
        MERGE (collection)<-[:COLLECTED_IN]-(recipe)
        RETURN recipe
        """
      )

    uncollectRecipe(input: RecipeCollectInput!): Recipe!
      @authenticated
      @cypher(
        statement: """
        MATCH (recipe:Recipe{id:$input.recipeId})
        OPTIONAL MATCH (user:User{id:$cypherParams.userId})-[:MEMBER_OF]->(:Group)-[:HAS_COLLECTION]->(:RecipeCollection)<-[rel:COLLECTED_IN]-(recipe)
        DELETE rel
        RETURN recipe
        """
      )
  }

  extend type Ingredient {
    usedIn: [RecipeIngredient!]! @relation(name: "USED_IN", direction: "OUT")
  }

  extend type User {
    authoredRecipes(first: Int = 10, offset: Int = 0): [Recipe!]!
      @cypher(
        statement: "MATCH (this)-[:AUTHOR_OF]->(r:Recipe {published: true}) RETURN r"
      )

    discoveredRecipes(first: Int = 10, offset: Int = 0): [Recipe!]!
      @relation(name: "DISCOVERER_OF", direction: "OUT")

    draftRecipes(first: Int = 10, offset: Int = 0): [Recipe!]!
      @cypher(
        statement: "MATCH (this)-[:AUTHOR_OF]->(r:Recipe {published: false}) RETURN r"
      )
  }

  extend type RecipeCollection {
    recipes(first: Int = 10, offset: Int = 0): [Recipe!]! @relation(name: "COLLECTED_IN", direction: "IN")
  }
`;

export const resolvers = {
  Query: {
    recipe: neo4jgraphql,

    recipes: neo4jgraphql,
  },
  Mutation: {
    createRecipe: neo4jgraphql,

    linkRecipe: async (_parent, args, ctx: Context) => {
      const linkResult = await ctx.scanning.linkRecipe(
        args.input.url,
        ctx.user.id,
      );

      const recipe = await ctx.graph.recipes.get(linkResult.recipeId);

      return {
        recipe,
        problems: linkResult.problems,
      };
    },

    updateRecipe: neo4jgraphql,

    publishRecipe: neo4jgraphql,

    recordRecipeView: (_parent, args, ctx) =>
      ctx.graph.recipes.recordView(args.id),

    collectRecipe: neo4jgraphql,

    uncollectRecipe: neo4jgraphql,
  },
  Recipe: {
    // default value of locked to true
    locked: parent => (parent.locked === null ? true : parent.locked),
    servings: parent => (parent.servings === null ? 1 : parent.servings),
    private: parent => (parent.private === null ? false : parent.private),
  },
};
