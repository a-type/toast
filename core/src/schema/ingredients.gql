# import Recipe from 'recipes.gql'

type RecipeIngredient {
  id: ID!
  text: String!
  ingredientStart: Int
  ingredientEnd: Int
  unit: String
  unitStart: Int
  unitEnd: Int
  quantity: Float!
  quantityStart: Int
  quantityEnd: Int
  comments: [String!]!
  preparations: [String!]!

  ingredient: Ingredient! @cypherNode(relationship: "USED_IN", direction: IN)
  recipe: Recipe! @cypherNode(relationship: "INGREDIENT_OF", direction: OUT)
}

type RecipeIngredientCreateResult {
  recipeIngredient: RecipeIngredient!
    @cypher(
      match: "(recipeIngredient:RecipeIngredient{id:$parent.recipeIngredientId})"
      return: "recipeIngredient"
    )
}

type RecipeIngredientUpdateResult {
  recipeIngredient: RecipeIngredient
    @cypher(
      match: "(recipeIngredient:RecipeIngredient{id:$parent.recipeIngredientId})"
      return: "recipeIngredient"
    )
}

type RecipeIngredientDeleteResult {
  # empty type... perhaps one day we will return something.
}

enum RecipeIngredientCorrectionStatus {
  Submitted
  Accepted
  Rejected
}

enum RecipeIngredientCorrectionType {
  Change
  Delete
  Add
}

# this type is backed by Firestore, not Neo4j
type RecipeIngredientCorrection {
  id: ID!
  status: RecipeIngredientCorrectionStatus!
  correctionType: RecipeIngredientCorrectionType!
  correctedFields: RecipeIngredientCorrectedFields
  correctedText: String

  recipe: Recipe!
    @cypher(
      match: "(recipe:Recipe{id: parent.recipeId})"
      return: "recipe"
    )
  recipeIngredient: RecipeIngredient
    @cypher(
      match: "(recipeIngredient:RecipeIngredient{id: parent.recipeIngredientId})"
      return: "recipeIngredient"
    )
}

type RecipeIngredientCorrectedFields {
  unit: String
  unitStart: Int
  unitEnd: Int
  quantity: Float
  quantityStart: Int
  quantityEnd: Int
  ingredientStart: Int
  ingredientEnd: Int
}

type Ingredient {
  id: ID!
  name: String!
  description: String
  attribution: String
  alternateNames: [String!]!
}

type IngredientDeleteResult {
  # empty type...
}

input RecipeIngredientCorrectionSubmitInput {
  recipeIngredientId: ID
  recipeId: String!
  correctionType: RecipeIngredientCorrectionType!
  correctedText: String
  correctedValue: RecipeIngredientCorrectedFieldsInput
}

input RecipeIngredientCorrectedFieldsInput {
  unit: String
  unitStart: Int
  unitEnd: Int
  quantity: Float
  quantityStart: Int
  quantityEnd: Int
  ingredientId: String
  ingredientStart: Int
  ingredientEnd: Int
}

input RecipeIngredientCorrectionsFilterInput {
  status: RecipeIngredientCorrectionStatus
}

input RecipeIngredientCorrectionAcceptInput {
  id: ID!
}

input RecipeIngredientCorrectionRejectInput {
  id: ID!
}

input IngredientCreateInput {
  name: String!
  description: String
  attribution: String
  alternateNames: [String!] = []
}

input IngredientUpdateInput {
  id: ID!
  fields: IngredientUpdateFieldsInput!
}

input IngredientUpdateFieldsInput {
  name: String
  description: String
  attribution: String
  alternateNames: [String!]
}

input IngredientMergeInput {
  primaryId: ID!
  secondaryId: ID!
}

input IngredientDeleteInput {
  id: ID!
}

type Mutation {
  submitRecipeIngredientCorrection(input: RecipeIngredientCorrectionSubmitInput!): RecipeIngredientCorrection!
    @authenticated

  acceptRecipeIngredientCorrection(input: RecipeIngredientCorrectionAcceptInput!): RecipeIngredientCorrection!
    @hasClaim(claim: "admin")

  rejectRecipeIngredientCorrection(input: RecipeIngredientCorrectionRejectInput!): RecipeIngredientCorrection!
    @hasClaim(claim: "admin")

  createIngredient(input: IngredientCreateInput!): Ingredient!
    @cypher(
      create: "(ingredient:Ingredient{id:$args.id})"
      set: "ingredient.name = $args.input, ingredient.searchHelpers = $args.input.alternateNames"
      return: "ingredient"
    )
    @generateId(fromArg: "input.name")
    @hasClaim(claim: "admin")

  updateIngredient(input: IngredientUpdateInput!): Ingredient
    @cypher(
      match: "(ingredient:Ingredient{id:$args.input.id})"
      set: "ingredient += $args.input.fields"
      return: "ingredient"
    )
    @hasClaim(claim: "admin")

  deleteIngredient(input: IngredientDeleteInput!): IngredientDeleteResult
    @cypher(
      match: "(ingredient:Ingredient{id:$args.input.id})"
      detachDelete: "ingredient"
      return: "{}"
    )

  mergeIngredients(input: MergeIngredientsInput!): Ingredient
    @cypherCustom(
      statement: """
      MATCH (secondary:Ingredient{id:$args.input.secondaryId}),
        (primary:Ingredient {id:$args.input.primaryId})
      WITH head(collect([primary, secondary])) as nodes, coalesce(primary.alternateNames, []) +
        coalesce(secondary.alternateNames, []) + secondary.name as newAlternateNames,
        coalesece(primary.searchHelpers, []) + coalesce(secondary.searchHelpers, []) as newSearchHelpers
      CALL apoc.refactor.mergeNodes(nodes, {properties: "discard"}) YIELD node
      SET node.alternateNames = newAlternateNames, node.searchHelpers = newSearchHelpers
      RETURN node
      """
    )
}
