import { gql } from 'apollo-server-express';
import { Context } from 'context';
import { neo4jgraphql } from 'neo4j-graphql-js';

export const typeDefs = gql`
  enum RecipeDisplayType {
    LINK
    FULL
  }

  type RecipeSavedEdge @relation(name: "SAVED", from: "User", to: "Recipe") {
    collection: String!
    user: User!
    recipe: Recipe!
  }

  type Recipe {
    id: ID!
    title: String!
    description: String
    attribution: String
    sourceUrl: String
    published: Boolean!
    displayType: RecipeDisplayType

    servings: Int!
    # all times in minutes
    cookTime: Int
    prepTime: Int
    unattendedTime: Int

    createdAt: String!
    updatedAt: String!
    viewedAt: String!
    views: Int!

    locked: Boolean!

    saved: [RecipeSavedEdge!]!
  }

  enum RecipeLinkProblem {
    FailedIngredients
    IncompleteIngredients
    FailedImage
  }

  type RecipeLinkResult {
    recipe: Recipe!
    problems: [RecipeLinkProblem!]!
  }

  input RecipeCreateInput {
    title: String!
    description: String
    servings: Int
    cookTime: Int
    prepTime: Int
    unattendedTime: Int
  }

  input RecipeLinkInput {
    url: String!
  }

  input RecipeSaveInput {
    recipeId: ID!
  }

  input RecipeUpdateInput {
    title: String
    description: String
    servings: Int
    cookTime: Int
    prepTime: Int
    unattendedTime: Int
  }

  # normally this would be generated by neo4j-graphql-js, but we're not
  # using schema augmentation yet...
  enum _RecipeOrdering {
    title_asc
    title_desc
    views_asc
    views_desc
  }

  extend type Query {
    recipe(id: ID!): Recipe
      # here we're preventing users from seeing drafts by other users
      @cypher(
        statement: """
        MATCH (recipe:Recipe {id:$id})
        OPTIONAL MATCH (author:User)-[:AUTHOR_OF]->(recipe)
        RETURN CASE
          WHEN author.id = $cypherParams.userId OR recipe.published
            THEN recipe
          ELSE NULL
        END
        """
      )

    recipes(
      orderBy: _RecipeOrdering
      first: Int = 10
      offset: Int = 0
    ): [Recipe!]!
      @cypher(
        statement: """
        MATCH (recipe:Recipe) RETURN recipe
        """
      )
  }

  extend type Mutation {
    createRecipe(input: RecipeCreateInput!): Recipe!
      @authenticated
      @generateId(fromArg: "input.title")
      @cypher(
        statement: """
        MATCH (user:User{id:$cypherParams.userId})
        CREATE (recipe:Recipe {id: $id})<-[:AUTHOR_OF]-(user)
        CREATE (recipe)<-[:SAVED{collection:'liked'}]-(user)
        SET recipe += $input
        SET recipe.displayType = 'FULL'
        SET recipe.published = false
        RETURN recipe
        """
      )

    linkRecipe(input: RecipeLinkInput!): RecipeLinkResult! @authenticated

    updateRecipe(id: ID!, input: RecipeUpdateInput!): Recipe
      @authenticated
      @cypher(
        statement: """
        MATCH (:User{id:$cypherParams.userId})-[:AUTHOR_OF]->(recipe:Recipe{id:$id})
        SET recipe += $input
        RETURN recipe
        """
      )

    publishRecipe(id: ID!): Recipe
      @authenticated
      @cypher(
        statement: """
        MATCH (:User{id:$cypherParams.userId})-[:AUTHOR_OF]->(recipe:Recipe{id:$id})
        SET recipe.published = true
        RETURN recipe
        """
      )
    recordRecipeView(id: ID!): Recipe

    saveRecipe(input: RecipeSaveInput!): Recipe!
      @authenticated
      @cypher(
        statement: """
        MATCH (recipe:Recipe{id:$input.recipeId}), (user:User{id:$cypherParams.userId})
        MERGE (user)-[:SAVED{collection:'liked'}]->(recipe)
        RETURN recipe
        """
      )

    unsaveRecipe(input: RecipeSaveInput!): Recipe!
      @authenticated
      @cypher(
        statement: """
        MATCH (recipe:Recipe{id:$input.recipeId}), (user:User{id:$cypherParams.userId})
        OPTIONAL MATCH (recipe)<-[rel:SAVED]-(user)
        DELETE rel
        RETURN recipe
        """
      )
  }

  extend type Ingredient {
    usedIn: [RecipeIngredient!]! @relation(name: "USED_IN", direction: "OUT")
  }

  extend type User {
    authoredRecipes(pagination: ListPaginationInput): [Recipe!]!
      @cypher(
        statement: "MATCH (this)-[:AUTHOR_OF]->(r:Recipe {published: true}) RETURN r"
      )

    discoveredRecipes(pagination: ListPaginationInput): [Recipe!]!
      @relation(name: "DISCOVERER_OF", direction: "OUT")

    draftRecipes(pagination: ListPaginationInput): [Recipe!]!
      @cypher(
        statement: "MATCH (this)-[:AUTHOR_OF]->(r:Recipe {published: false}) RETURN r"
      )

    savedRecipes(first: Int, offset: Int): [RecipeSavedEdge!]!
  }
`;

export const resolvers = {
  Query: {
    recipe: neo4jgraphql,

    recipes: neo4jgraphql,
  },
  Mutation: {
    createRecipe: neo4jgraphql,

    linkRecipe: async (_parent, args, ctx: Context) => {
      const linkResult = await ctx.scanning.linkRecipe(
        args.input.url,
        ctx.user.id,
      );

      const recipe = await ctx.graph.recipes.get(linkResult.recipeId);

      return {
        recipe,
        problems: linkResult.problems,
      };
    },

    updateRecipe: neo4jgraphql,

    publishRecipe: neo4jgraphql,

    recordRecipeView: (_parent, args, ctx) =>
      ctx.graph.recipes.recordView(args.id),

    saveRecipe: neo4jgraphql,

    unsaveRecipe: neo4jgraphql,
  },
  Recipe: {
    // default value of locked to true
    locked: parent => (parent.locked === null ? true : parent.locked),
    servings: parent => (parent.servings === null ? 1 : parent.servings),
  },
};
